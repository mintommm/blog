name: Download Content, Build and Deploy

on:
  schedule:
    # UTCの 00:00, 06:00, 12:00, 18:00 に実行 (6時間ごと)
    - cron: '0 0,6,12,18 * * *'
  workflow_dispatch: # 手動実行を許可
    inputs:
      ignore_cache:
        description: 'キャッシュを無視してコンテンツを強制的に再ダウンロードしますか？ (true/false)'
        required: false
        default: 'false'
        type: boolean

jobs:
  build_and_deploy: # ジョブ名を変更
    runs-on: ubuntu-latest
    permissions:
      contents: 'write' # main.pyがcontentディレクトリに書き込むため & Cloudflare Pages Actionで必要になる可能性
      id-token: 'write' # Workload Identity Federationに必要
    concurrency: # 同時実行制御
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: true # Hugoテーマがサブモジュールの場合に必要
        fetch-depth: 0 # Gitの履歴をすべて取得 (Lastmodなどに必要)

    - name: Disable quotePath # 非ASCIIファイル名対応
      run: git config core.quotePath false

    # --- Direct Workload Identity Federation Steps ---
    - name: Install jq
      run: sudo apt-get update && sudo apt-get install -y jq

    - name: Get GitHub OIDC token
      id: oidc_token
      uses: actions/github-script@v7
      with:
        script: |
          const audience = process.env.GCP_WIF_PROVIDER;
          if (!audience) {
            core.setFailed('GCP_WIF_PROVIDER environment variable is not set.');
            return;
          }
          console.log(`Requesting OIDC token with audience: ${audience}`);
          const token = await core.getIDToken(audience);
          core.setOutput('token', token);
        result-encoding: string
      env:
        GCP_WIF_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}

    - name: Exchange GitHub OIDC token for Google Access Token
      id: google_token
      run: |
        # Construct the STS request payload
        # Note: Adjust the scope as needed for the APIs your script uses (e.g., drive, storage)
        read -r -d '' STS_PAYLOAD << EOM
        {
          "audience": "//iam.googleapis.com/${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}",
          "grantType": "urn:ietf:params:oauth:grant-type:token-exchange",
          "requestedTokenType": "urn:ietf:params:oauth:token-type:access_token",
          "scope": "https://www.googleapis.com/auth/drive.readonly",
          "subjectTokenType": "urn:ietf:params:oauth:token-type:jwt",
          "subjectToken": "${{ steps.oidc_token.outputs.token }}"
        }
        EOM
        echo "--- STS Request Payload ---"
        echo "$STS_PAYLOAD"
        echo "---------------------------"

        # Exchange the token using Google STS API with verbose output, not silent
        echo "--- curl STS Request ---"
        # Remove -s, keep -v
        ACCESS_TOKEN_RESPONSE=$(curl -v -X POST "https://sts.googleapis.com/v1/token" \
          -H "Content-Type: application/json" \
          -d "$STS_PAYLOAD")
        CURL_EXIT_CODE=$?
        echo # Add a newline for better log separation
        echo "--- curl STS Response Body ---"
        echo "$ACCESS_TOKEN_RESPONSE"
        echo "-----------------------------"
        echo "curl exit code: $CURL_EXIT_CODE"

        if [ $CURL_EXIT_CODE -ne 0 ]; then
          echo "::error::curl command failed with exit code $CURL_EXIT_CODE."
          # No need to print response here, curl -v should have shown it
          exit 1
        fi

        # Basic check for error in response instead of relying on jq parsing
        # Check if the response contains '"error":'
        if echo "$ACCESS_TOKEN_RESPONSE" | grep -q '"error":'; then
            echo "::error::Detected error in STS Response."
            echo "Raw STS Response was:"
            echo "$ACCESS_TOKEN_RESPONSE"
            exit 1
        fi

        # If no error detected, try to extract token with jq (best effort for now)
        ACCESS_TOKEN=$(echo "$ACCESS_TOKEN_RESPONSE" | jq -r .access_token)

        # Final check if token is empty after potential jq parse
        if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
            echo "::error::Failed to extract access_token from STS response (jq parse failed or token empty)."
            echo "Raw STS Response was:"
            echo "$ACCESS_TOKEN_RESPONSE"
            exit 1
        fi

        # Mask the token in logs and set it as output
        echo "::add-mask::$ACCESS_TOKEN"
        echo "access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
      env:
         # Secrets are used directly in the payload construction above
         GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}

    # --- End Direct Workload Identity Federation Steps ---

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version-file: '.python-version' # .python-version ファイルからバージョンを読み込む

    - name: Install uv and dependencies
      run: |
        python -m pip install --upgrade pip uv
        uv sync --system-site-packages # uv.lockに基づいて依存関係をインストール

    - name: Restore content cache
      id: cache-content
      if: github.event.inputs.ignore_cache != 'true' # 手動実行でignore_cacheがtrueでない場合のみ実行
      uses: actions/cache@v4
      with:
        path: content # キャッシュ対象ディレクトリ
        key: ${{ runner.os }}-markdown-content-${{ hashFiles('main.py') }} # OSとmain.pyのハッシュでキーを生成
        # restore-keys: | # 必要に応じて古いキャッシュからの復元キーを追加
        #   ${{ runner.os }}-markdown-content-

    - name: Remove old marker file # Previous marker file cleanup
      run: rm -f .content-updated

    - name: Run Python script
      run: python main.py # Google Driveにアクセスするスクリプトを実行 (スクリプト内でファイル有無/更新日時を確認)
      env:
        GOOGLE_DRIVE_PARENT_ID: ${{ secrets.GOOGLE_DRIVE_PARENT_ID }} # GitHub Secretsから親ディレクトリIDを渡す
        GOOGLE_OAUTH_ACCESS_TOKEN: ${{ steps.google_token.outputs.access_token }} # Set the obtained Google Access Token
        # 他に必要な環境変数があればここに追加

    - name: Check for content update marker
      id: check_update_marker
      run: |
        if [ -f ".content-updated" ]; then
          echo "Content was updated by main.py."
          echo "content_was_updated=true" >> $GITHUB_OUTPUT
        else
          echo "Content was not updated by main.py."
          echo "content_was_updated=false" >> $GITHUB_OUTPUT
        fi

    - name: Save content cache # ignore_cacheがtrueでない場合のみ実行 (main.pyによる変更を常に保存)
      if: github.event.inputs.ignore_cache != 'true'
      uses: actions/cache/save@v4 # actions/cache@v4 の if 条件で制御
      with:
        path: content # キャッシュ対象ディレクトリ
        key: ${{ runner.os }}-markdown-content-${{ hashFiles('main.py') }} # 保存キーは復元キーと同じにする

    # --- Hugo Build and Deploy Steps ---
    - name: Setup Hugo
      uses: peaceiris/actions-hugo@v3
      with:
        hugo-version: 'latest' # または特定のバージョンを指定
        extended: true # SASS/SCSSを使用する場合はtrue

    - name: Build Hugo site
      env:
        TZ: Asia/Tokyo # タイムゾーン設定
      run: hugo --minify # minifyオプション付きでビルド

    - name: Deploy to Cloudflare Pages
      # コンテンツが更新されたか、キャッシュ無視の場合のみデプロイ
      if: steps.check_update_marker.outputs.content_was_updated == 'true' || github.event.inputs.ignore_cache == 'true'
      uses: cloudflare/pages-action@v1
      with:
        apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }} # GitHub Secretsに設定してください
        accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }} # GitHub Secretsに設定してください
        projectName: ${{ secrets.CLOUDFLARE_PROJECT_NAME }} # GitHub Secretsに設定してください
        directory: public # Hugoの出力ディレクトリ
        # Optional: Branch specific deployment
        # branch: main # デプロイ対象のブランチ (デフォルトはGitHub Actionsを実行したブランチ)
        gitHubToken: ${{ secrets.GITHUB_TOKEN }} # Optional: For pull request previews
